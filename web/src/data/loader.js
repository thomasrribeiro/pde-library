/**
 * Data loader for pre-computed solver results.
 * Always loads .npz files from GitHub raw URLs.
 * Uses manifest.json to know what data is available.
 */

import { load_solver_data_from_npz } from './npz-loader.js';

const cache = new Map();

// GitHub repository configuration
const GITHUB_RAW_BASE_URL = 'https://raw.githubusercontent.com/thomasrribeiro/pde-library/master';

// Cached manifest
let manifest_cache = null;

/**
 * Load the manifest of available benchmark results.
 * The manifest is generated by scripts/generate_web_manifest.py and lists
 * all problems with computed results, their solvers, and resolutions.
 *
 * @returns {Promise<Object>} Manifest object
 */
export async function load_manifest() {
    if (manifest_cache) {
        return manifest_cache;
    }

    const url = `${GITHUB_RAW_BASE_URL}/web/public/manifest.json`;

    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.error(`[loader] Failed to load manifest: ${response.status}`);
            return null;
        }
        manifest_cache = await response.json();
        console.log('[loader] Manifest loaded successfully');
        return manifest_cache;
    } catch (error) {
        console.error(`[loader] Failed to load manifest: ${error.message}`);
        return null;
    }
}

/**
 * Load pre-computed solver data from .npz file.
 * Always fetches from GitHub raw URLs.
 *
 * @param {string} equation - Equation name (e.g., 'laplace')
 * @param {string} boundary_condition - BC name (e.g., 'dirichlet')
 * @param {string} dimension - Dimension (e.g., '2d')
 * @param {string} solver - Solver name (e.g., 'warp', 'dolfinx')
 * @param {number} resolution - Grid resolution
 * @returns {Promise<Object>} Loaded data with x, y, values arrays
 */
export async function load_solver_data(equation, boundary_condition, dimension, solver, resolution) {
    const cache_key = `${equation}/${boundary_condition}/${dimension}/${solver}_res${String(resolution).padStart(3, '0')}`;

    if (cache.has(cache_key)) {
        return cache.get(cache_key);
    }

    try {
        const data = await load_solver_data_from_npz(equation, boundary_condition, dimension, solver, resolution, true);
        cache.set(cache_key, data);
        return data;
    } catch (error) {
        console.error(`Error loading solver data: ${error.message}`);
        return null;
    }
}

/**
 * Clear the data cache.
 */
export function clear_cache() {
    cache.clear();
}

/**
 * Load problem description from description.txt file in benchmark directory.
 * Always fetches from GitHub raw URLs.
 *
 * @param {string} equation - Equation name (e.g., 'laplace')
 * @param {string} boundary_condition - BC name (e.g., 'dirichlet')
 * @param {string} dimension - Dimension (e.g., '2d')
 * @returns {Promise<string|null>} Description text or null if not found
 */
export async function load_problem_description(equation, boundary_condition, dimension) {
    const cache_key = `description_${equation}/${boundary_condition}/${dimension}`;

    if (cache.has(cache_key)) {
        return cache.get(cache_key);
    }

    const relative_path = `benchmarks/${equation}/_${dimension}/${boundary_condition}/description.txt`;
    const url = `${GITHUB_RAW_BASE_URL}/${relative_path}`;

    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.log(`[loader] No description found at ${url}`);
            return null;
        }
        const description = await response.text();
        cache.set(cache_key, description.trim());
        return description.trim();
    } catch (error) {
        console.log(`[loader] Failed to load description: ${error.message}`);
        return null;
    }
}
